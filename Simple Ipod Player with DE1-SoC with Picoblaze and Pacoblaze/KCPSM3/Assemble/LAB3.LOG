KCPSM3 Assembler log file for program 'lab3.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
24Feb2020-30:48:30

 Addr Code

 000                               ;**************************************************************************************
 000                               ; Port definitions
 000                               ;**************************************************************************************
 000                               ;
 000                               ;
 000                               ;
 000                               CONSTANT LED_port, 80               ;8 simple LEDs. Is an OUTPUT port. for LED[9:2]
 000                               CONSTANT DATA_IN_PORT, 00           ;input data port. this is an INPUT port.
 000                               CONSTANT LED_0, 40
 000                               CONSTANT ISR_preserve_s0, 00        ;Preserve s0 contents during ISR
 000                               CONSTANT ISR_preserve_s1, 01        ;Preserve s1 contents during ISR
 000                               CONSTANT ISR_preserve_s2, 02        ;Preserve s2 contents during ISR
 000                               CONSTANT ISR_preserve_s3, 03        ;Preserve s3 contents during ISR
 000                               CONSTANT ISR_preserve_s4, 04
 000                               CONSTANT ISR_preserve_s5, 05
 000                               CONSTANT sum1, 06
 000                               CONSTANT sum2, 07
 000                               CONSTANT counter, 08
 000                               ;
 000                               CONSTANT LED_pattern, 04            ;remember state of LEDs (8-bit counter in this case)
 000                               ;
 000                               ;**************************************************************************************
 000                               ; Useful data constants
 000                               ;**************************************************************************************
 000                               ;
 000                               ;
 000                               ; Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                               ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                               ; calculation highly predictable. The '6' in the following equation even allows for
 000                               ; 'CALL delay_1us' instruction in the initiating code.
 000                               ;
 000                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                               ;
 000                               ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                               ; For clock rates below 10MHz the value of 1 must be used and the operation will
 000                               ; become lower than intended. Interrupts may effect the timing of software based
 000                               ; delays.
 000                               ;
 000                               CONSTANT delay_1us_constant, 05
 000                               ;
 000                               ;
 000                               ;
 000                               ; ASCII table
 000                               ;
 000                               CONSTANT character_a, 61
 000                               CONSTANT character_b, 62
 000                               CONSTANT character_c, 63
 000                               CONSTANT character_d, 64
 000                               CONSTANT character_e, 65
 000                               CONSTANT character_f, 66
 000                               CONSTANT character_g, 67
 000                               CONSTANT character_h, 68
 000                               CONSTANT character_i, 69
 000                               CONSTANT character_j, 6A
 000                               CONSTANT character_k, 6B
 000                               CONSTANT character_l, 6C
 000                               CONSTANT character_m, 6D
 000                               CONSTANT character_n, 6E
 000                               CONSTANT character_o, 6F
 000                               CONSTANT character_p, 70
 000                               CONSTANT character_q, 71
 000                               CONSTANT character_r, 72
 000                               CONSTANT character_s, 73
 000                               CONSTANT character_t, 74
 000                               CONSTANT character_u, 75
 000                               CONSTANT character_v, 76
 000                               CONSTANT character_w, 77
 000                               CONSTANT character_x, 78
 000                               CONSTANT character_y, 79
 000                               CONSTANT character_z, 7A
 000                               CONSTANT character_A, 41
 000                               CONSTANT character_B, 42
 000                               CONSTANT character_C, 43
 000                               CONSTANT character_D, 44
 000                               CONSTANT character_E, 45
 000                               CONSTANT character_F, 46
 000                               CONSTANT character_G, 47
 000                               CONSTANT character_H, 48
 000                               CONSTANT character_I, 49
 000                               CONSTANT character_J, 4A
 000                               CONSTANT character_K, 4B
 000                               CONSTANT character_L, 4C
 000                               CONSTANT character_M, 4D
 000                               CONSTANT character_N, 4E
 000                               CONSTANT character_O, 4F
 000                               CONSTANT character_P, 50
 000                               CONSTANT character_Q, 51
 000                               CONSTANT character_R, 52
 000                               CONSTANT character_S, 53
 000                               CONSTANT character_T, 54
 000                               CONSTANT character_U, 55
 000                               CONSTANT character_V, 56
 000                               CONSTANT character_W, 57
 000                               CONSTANT character_X, 58
 000                               CONSTANT character_Y, 59
 000                               CONSTANT character_Z, 5A
 000                               CONSTANT character_0, 30
 000                               CONSTANT character_1, 31
 000                               CONSTANT character_2, 32
 000                               CONSTANT character_3, 33
 000                               CONSTANT character_4, 34
 000                               CONSTANT character_5, 35
 000                               CONSTANT character_6, 36
 000                               CONSTANT character_7, 37
 000                               CONSTANT character_8, 38
 000                               CONSTANT character_9, 39
 000                               CONSTANT character_colon, 3A
 000                               CONSTANT character_stop, 2E
 000                               CONSTANT character_semi_colon, 3B
 000                               CONSTANT character_minus, 2D
 000                               CONSTANT character_divide, 2F       ;'/'
 000                               CONSTANT character_plus, 2B
 000                               CONSTANT character_comma, 2C
 000                               CONSTANT character_less_than, 3C
 000                               CONSTANT character_greater_than, 3E
 000                               CONSTANT character_equals, 3D
 000                               CONSTANT character_space, 20
 000                               CONSTANT character_CR, 0D           ;carriage return
 000                               CONSTANT character_question, 3F     ;'?'
 000                               CONSTANT character_dollar, 24
 000                               CONSTANT character_exclaim, 21      ;'!'
 000                               CONSTANT character_BS, 08           ;Back Space command character
 000                               ;
 000                               ;
 000                               ;
 000                               ;
 000                               ;
 000                               ;**************************************************************************************
 000                               ; Initialise the system
 000                               ;**************************************************************************************
 000                               ;
 000  00000            cold_start: LOAD s0, 00
 001  2E004                        STORE s0, LED_pattern[04]
 002  2C080                        OUTPUT s0, LED_port[80]
 003  3C001                        ENABLE INTERRUPT                    ;now interrupts are on
 004                               ;*******************PART1*******************;
 004                 main_program: 
 004  00601                        LOAD s6, 01                         ;mov s1,#1
 005  2C640                        OUTPUT s6, LED_0[40]                ;now the LED0 is on
 006  3001E                        CALL delay_1s[01E]                  ;wait 1 second
 007  00600                        LOAD s6, 00                         ;mov s1,#0
 008  2C640                        OUTPUT s6, LED_0[40]                ;now the LED0 is off
 009  3001E                        CALL delay_1s[01E]                  ;wait 1 second
 00A  34004                        JUMP main_program[004]
 00B                               ;**************************************************************************************
 00B                               ; Software delay routines
 00B                               ;**************************************************************************************
 00B                               ;
 00B                               ; Delay of 1us.
 00B                               ;
 00B                               ; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
 00B                               ; instruction executes in 2 clock cycles making the calculation highly predictable.
 00B                               ; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
 00B                               ; in the initiating code. Interrupts may effect software derived delays.
 00B                               ;
 00B                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 00B                               ;
 00B                               ; Registers used s0
 00B  00005             delay_1us: LOAD s0, delay_1us_constant[05]
 00C  1C001              wait_1us: SUB s0, 01
 00D  3540C                        JUMP NZ, wait_1us[00C]
 00E  2A000                        RETURN
 00F                               ;
 00F                               ; Delay of 40us.
 00F                               ;
 00F                               ; Registers used s0, s1
 00F                               ;
 00F  00128            delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
 010  3000B             wait_40us: CALL delay_1us[00B]
 011  1C101                        SUB s1, 01
 012  35410                        JUMP NZ, wait_40us[010]
 013  2A000                        RETURN
 014                               ;
 014                               ;
 014                               ; Delay of 1ms.
 014                               ;
 014                               ; Registers used s0, s1, s2
 014                               ;
 014  00219             delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
 015  3000F              wait_1ms: CALL delay_40us[00F]
 016  1C201                        SUB s2, 01
 017  35415                        JUMP NZ, wait_1ms[015]
 018  2A000                        RETURN
 019                               ;
 019                               ; Delay of 20ms.
 019                               ;
 019                               ; Delay of 20ms used during initialisation.
 019                               ;
 019                               ; Registers used s0, s1, s2, s3
 019                               ;
 019  00314            delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
 01A  30014             wait_20ms: CALL delay_1ms[014]
 01B  1C301                        SUB s3, 01
 01C  3541A                        JUMP NZ, wait_20ms[01A]
 01D  2A000                        RETURN
 01E                               ;
 01E                               ; Delay of approximately 1 second.
 01E                               ;
 01E                               ; Registers used s0, s1, s2, s3, s4
 01E                               ;
 01E  00432              delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
 01F  30019               wait_1s: CALL delay_20ms[019]
 020  1C401                        SUB s4, 01
 021  3541F                        JUMP NZ, wait_1s[01F]
 022  2A000                        RETURN                              ;from pracPICO.psm
 023                               ;*******************PART2***************************;
 023                               ;some important comments:
 023                               ;we need to read the data and then  s1 counter s2 sum
 023                          ISR: 
 023  2E000                        STORE s0, ISR_preserve_s0[00]       ;data
 024  2E101                        STORE s1, ISR_preserve_s1[01]       ;let's use it as a counter
 025  2E202                        STORE s2, ISR_preserve_s2[02]       ;let's use it as sum1
 026  2E303                        STORE s3, ISR_preserve_s3[03]       ;let's use it as sum2
 027  2E404                        STORE s4, ISR_preserve_s4[04]       ;let's use it as unimportant sum
 028  2E505                        STORE s5, ISR_preserve_s5[05]       ;this is the output of led
 029  06108                        FETCH s1, counter[08]               ; reload the values of this
 02A  06206                        FETCH s2, sum1[06]
 02B  06307                        FETCH s3, sum2[07]
 02C  04000                        INPUT s0, DATA_IN_PORT[00]          ; s0 gets the data
 02D  14080                        COMPARE s0, 80                      ; see if the msb is 1 which means negative
 02E  35C3F                        JUMP NC, negative_to_positive[03F]
 02F                    continue1: 
 02F                               ;now  256 times wait
 02F  19200                        ADD s2, s0                          ;  now add this sum1
 030  3583D                        JUMP C, increment_LED[03D]
 031                      counter: 
 031  18101                        ADD s1, 01                          ;will finish it after it reaches to FF
 032  35842                        JUMP C, got_256[042]
 033  2E108                        STORE s1, counter[08]               ;save them to memory
 034  2E206                        STORE s2, sum1[06]
 035  2E307                        STORE s3, sum2[07]
 036  06000                        FETCH s0, ISR_preserve_s0[00]       ;let's return them to the stack
 037  06101                        FETCH s1, ISR_preserve_s1[01]
 038  06202                        FETCH s2, ISR_preserve_s2[02]
 039  06303                        FETCH s3, ISR_preserve_s3[03]
 03A  06404                        FETCH s4, ISR_preserve_s4[04]
 03B  06505                        FETCH s5, ISR_preserve_s5[05]
 03C  38001                        RETURNI ENABLE
 03D                increment_LED: 
 03D  18301                        ADD s3, 01                          ;sum2 is incrementing by 1
 03E  34031                        JUMP counter[031]
 03F         negative_to_positive: 
 03F  0E0FF                        XOR s0, FF
 040  18001                        ADD s0, 01                          ;now we convert negative to positive
 041  3402F                        JUMP continue1[02F]
 042                      got_256: ;here we will compare the value of sum2 then output it to LEDs
 042                               ;let's say we got 5 = 00000101 then we need to get xxx00000
 042  20206                        SL0 s2
 043  35C47                        JUMP NC, six[047]
 044  005FF                        LOAD s5, FF                         ;LED2
 045  2C580                        OUTPUT s5, LED_port[80]
 046  3406A                        JUMP END[06A]
 047                          six: 
 047  20206                        SL0 s2
 048  35C4C                        JUMP NC, five[04C]
 049  005FE                        LOAD s5, FE
 04A  2C580                        OUTPUT s5, LED_port[80]
 04B  3406A                        JUMP END[06A]
 04C                         five: 
 04C  20206                        SL0 s2
 04D  35C51                        JUMP NC, four[051]
 04E  005FC                        LOAD s5, FC
 04F  2C580                        OUTPUT s5, LED_port[80]
 050  3406A                        JUMP END[06A]
 051                         four: 
 051  20206                        SL0 s2
 052  35C56                        JUMP NC, three[056]
 053  005F8                        LOAD s5, F8
 054  2C580                        OUTPUT s5, LED_port[80]
 055  3406A                        JUMP END[06A]
 056                        three: 
 056  20206                        SL0 s2
 057  35C5B                        JUMP NC, two[05B]
 058  005F0                        LOAD s5, F0
 059  2C580                        OUTPUT s5, LED_port[80]
 05A  3406A                        JUMP END[06A]
 05B                          two: 
 05B  20206                        SL0 s2
 05C  35C60                        JUMP NC, one[060]
 05D  005E0                        LOAD s5, E0
 05E  2C580                        OUTPUT s5, LED_port[80]
 05F  3406A                        JUMP END[06A]
 060                          one: 
 060  20206                        SL0 s2
 061  35C65                        JUMP NC, zero[065]
 062  005C0                        LOAD s5, C0
 063  2C580                        OUTPUT s5, LED_port[80]
 064  3406A                        JUMP END[06A]
 065                         zero: 
 065  20206                        SL0 s2
 066  35C6A                        JUMP NC, END[06A]
 067  00580                        LOAD s5, 80
 068  2C580                        OUTPUT s5, LED_port[80]
 069  3406A                        JUMP END[06A]
 06A                          END: 
 06A  00100                        LOAD s1, 00                         ; reset
 06B  00200                        LOAD s2, 00
 06C  00300                        LOAD s3, 00
 06D  2E108                        STORE s1, counter[08]               ; save to memory
 06E  2E206                        STORE s2, sum1[06]
 06F  2E307                        STORE s3, sum2[07]
 070  06000                        FETCH s0, ISR_preserve_s0[00]       ;let's return them to the stack
 071  06101                        FETCH s1, ISR_preserve_s1[01]
 072  06202                        FETCH s2, ISR_preserve_s2[02]
 073  06303                        FETCH s3, ISR_preserve_s3[03]
 074  06404                        FETCH s4, ISR_preserve_s4[04]
 075  06505                        FETCH s5, ISR_preserve_s5[05]
 076  38001                        RETURNI ENABLE
 077                               ;**************************************************************************************
 077                               ; Interrupt Vector
 077                               ;**************************************************************************************
 077                               ;
 3FF                               ADDRESS 3FF                         ;for interrupt
 3FF  34023                        JUMP ISR[023]                       ;for interrupt
 3FF                               ;
 3FF                               ;
